const scene=new THREE.Scene()
    const camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,5000)
    camera.position.set(0,50,250)
    const renderer=new THREE.WebGLRenderer({antialias:true})
    renderer.setSize(window.innerWidth,window.innerHeight)
    document.body.appendChild(renderer.domElement)
    const controls=new THREE.OrbitControls(camera,renderer.domElement)
    controls.enablePan=false
    const earthRadius=10
    controls.minDistance=earthRadius*1.1
    controls.maxDistance=400





const earthOrbit=new THREE.Object3D()
    scene.add(earthOrbit)

    const earthGeometry=new THREE.SphereGeometry(earthRadius,128,128)
    const earthMaterial=new THREE.MeshPhongMaterial({
      map:new THREE.TextureLoader().load("earth.atmos.jpg"),
      specularMap:new THREE.TextureLoader().load("eartg.specular.jpg"),
      bumpMap:new THREE.TextureLoader().load("earth.bump.jpg"),
      bumpScale:0.1,
      side:THREE.FrontSide
    })
    const earth=new THREE.Mesh(earthGeometry,earthMaterial)
    earth.position.set(150,0,0)
    earthOrbit.add(earth)





fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json') .then(res => res.json()) .then(worldData => { const countries = topojson.feature(worldData, worldData.objects.countries); const material = new THREE.LineBasicMaterial({ color: 0xffffff }); countries.features.forEach(feature => { const coords = feature.geometry.coordinates; if (feature.geometry.type === "Polygon") { drawPolygon(coords); } else if (feature.geometry.type === "MultiPolygon") { coords.forEach(polygon => drawPolygon(polygon)); } }); function drawPolygon(polygon) { polygon.forEach(ring => { const points = []; ring.forEach(([lon, lat]) => { points.push(latLngToVector3(lat, lon, earthRadius)); }); const geometry = new THREE.BufferGeometry().setFromPoints(points); const line = new THREE.Line(geometry, material); earth.add(line); }); } }) .catch(err => console.error(err));
    const clock=new THREE.Clock()
    function animate(){
      requestAnimationFrame(animate)
      const t=clock.getElapsedTime()
      earth.rotation.y+=0.01
      earthOrit.rotabtion.y=t*0
      moon.position.set(Math.cos(t*2)*25,0,Math.sin(t*2)*25)
      controls.target.copy(earth.getWorldPosition(new THREE.Vector3()))
      controls.update()
      renderer.render(scene,camera)
    }
    animate()

    window.addEventListener("resize",()=>{
      camera.aspect=window.innerWidth/window.innerHeight
      camera.updateProjectionMatrix()
      renderer.setSize(window.innerWidth,window.innerHeight)
    })






const sunLight = new THREE.PointLight(0xffffff, 1.5, 1000);
sunLight.position.set(500, 0, 0); 
scene.add(sunLight);

function latLngToVector3(lat,lng,radius){
      const phi=(90-lat)*Math.PI/180
      const theta=(lng+180)*Math.PI/180
      const x=-radius*Math.sin(phi)*Math.cos(theta)
      const y=radius*Math.cos(phi)
      const z=radius*Math.sin(phi)*Math.sin(theta)
      return new THREE.Vector3(x,y,z)
    }

    fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json')
  .then(res => res.json())
  .then(worldData => {
    const countries = topojson.feature(worldData, worldData.objects.countries);
    const material = new THREE.LineBasicMaterial({ color: 0xffffff });

    countries.features.forEach(feature => {
      const coords = feature.geometry.coordinates;
      let allCoords = [];

      if (feature.geometry.type === "Polygon") {
        drawPolygon(coords);
        allCoords = coords.flat();
      } else if (feature.geometry.type === "MultiPolygon") {
        coords.forEach(polygon => drawPolygon(polygon));
        allCoords = coords.flat(2);
      }

      const center = getPolygonCenter([allCoords]);
      addCountryLabel(feature.properties.name || "Unknown", center);
    }); 
    } )

    function drawPolygon(polygon) {
      polygon.forEach(ring => {
        const points = [];
        ring.forEach(([lon, lat]) => { points.push(latLngToVector3(lat, lon, earthRadius)); });
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        earth.add(line);
      });
    }







