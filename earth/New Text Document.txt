const scene=new THREE.Scene()
    const camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,5000)
    camera.position.set(0,50,250)
    const renderer=new THREE.WebGLRenderer({antialias:true})
    renderer.setSize(window.innerWidth,window.innerHeight)
    document.body.appendChild(renderer.domElement)
    const controls=new THREE.OrbitControls(camera,renderer.domElement)
    controls.enablePan=false
    const earthRadius=10
    controls.minDistance=earthRadius*1.1
    controls.maxDistance=400





const earthOrbit=new THREE.Object3D()
    scene.add(earthOrbit)

    const earthGeometry=new THREE.SphereGeometry(earthRadius,128,128)
    const earthMaterial=new THREE.MeshPhongMaterial({
      map:new THREE.TextureLoader().load("earth.atmos.jpg"),
      specularMap:new THREE.TextureLoader().load("eartg.specular.jpg"),
      bumpMap:new THREE.TextureLoader().load("earth.bump.jpg"),
      bumpScale:0.1,
      side:THREE.FrontSide
    })
    const earth=new THREE.Mesh(earthGeometry,earthMaterial)
    earth.position.set(150,0,0)
    earthOrbit.add(earth)





fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json') .then(res => res.json()) .then(worldData => { const countries = topojson.feature(worldData, worldData.objects.countries); const material = new THREE.LineBasicMaterial({ color: 0xffffff }); countries.features.forEach(feature => { const coords = feature.geometry.coordinates; if (feature.geometry.type === "Polygon") { drawPolygon(coords); } else if (feature.geometry.type === "MultiPolygon") { coords.forEach(polygon => drawPolygon(polygon)); } }); function drawPolygon(polygon) { polygon.forEach(ring => { const points = []; ring.forEach(([lon, lat]) => { points.push(latLngToVector3(lat, lon, earthRadius)); }); const geometry = new THREE.BufferGeometry().setFromPoints(points); const line = new THREE.Line(geometry, material); earth.add(line); }); } }) .catch(err => console.error(err));
    const clock=new THREE.Clock()
    function animate(){
      requestAnimationFrame(animate)
      const t=clock.getElapsedTime()
      earth.rotation.y+=0.01
      earthOrit.rotabtion.y=t*0
      moon.position.set(Math.cos(t*2)*25,0,Math.sin(t*2)*25)
      controls.target.copy(earth.getWorldPosition(new THREE.Vector3()))
      controls.update()
      renderer.render(scene,camera)
    }
    animate()

    window.addEventListener("resize",()=>{
      camera.aspect=window.innerWidth/window.innerHeight
      camera.updateProjectionMatrix()
      renderer.setSize(window.innerWidth,window.innerHeight)
    })






const sunLight = new THREE.PointLight(0xffffff, 1.5, 1000);
sunLight.position.set(500, 0, 0); 
scene.add(sunLight);

function latLngToVector3(lat,lng,radius){
      const phi=(90-lat)*Math.PI/180
      const theta=(lng+180)*Math.PI/180
      const x=-radius*Math.sin(phi)*Math.cos(theta)
      const y=radius*Math.cos(phi)
      const z=radius*Math.sin(phi)*Math.sin(theta)
      return new THREE.Vector3(x,y,z)
    }

    fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json')
  .then(res => res.json())
  .then(worldData => {
    const countries = topojson.feature(worldData, worldData.objects.countries);
    const material = new THREE.LineBasicMaterial({ color: 0xffffff });

    countries.features.forEach(feature => {
      const coords = feature.geometry.coordinates;
      let allCoords = [];

      if (feature.geometry.type === "Polygon") {
        drawPolygon(coords);
        allCoords = coords.flat();
      } else if (feature.geometry.type === "MultiPolygon") {
        coords.forEach(polygon => drawPolygon(polygon));
        allCoords = coords.flat(2);
      }

      const center = getPolygonCenter([allCoords]);
      addCountryLabel(feature.properties.name || "Unknown", center);
    }); 
    } )

    function drawPolygon(polygon) {
      polygon.forEach(ring => {
        const points = [];
        ring.forEach(([lon, lat]) => { points.push(latLngToVector3(lat, lon, earthRadius)); });
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        earth.add(line);
      });
    }




const sunLight=new THREE.PointLight(0xffffff,3,0) 
    sunLight.position.set(0,0,0) 
    scene.add(sunLight) 
    scene.add(new THREE.AmbientLight(0xffffff,1.2))


NormalMap:new THREE.textureLoader().load("normal.earth.jpg"),



map:new THREE.TextureLoader().load("https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg"),
specularMap:new THREE.TextureLoader().load("https://threejs.org/examples/textures/planets/earth_specular_2048.jpg"),
bumpMap:new THREE.TextureLoader().load("https://threejs.org/examples/textures/planets/earth_bump_2048.jpg"),




// bumpTexture 替换成 displacementMap
// craterImg: 小坑灰度图
function addCraterToDisplacement(displacementMap, craterImg, lat, lng, size){
  const width = displacementMap.image.width;
  const height = displacementMap.image.height;

  // 创建临时 canvas
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');

  // 画原 displacementMap
  ctx.drawImage(displacementMap.image, 0, 0, width, height);

  // 经纬度 -> 像素位置
  const {u, v} = latLngToUV(lat, lng, width, height);

  // 在对应位置画小坑
  ctx.drawImage(craterImg, u - size/2, v - size/2, size, size);

  // 更新 displacementMap
  displacementMap.image = canvas;
  displacementMap.needsUpdate = true;
}

const craterImg = new Image();
craterImg.src = 'small_crater_gray.png'; // 黑色区域表示凹陷
craterImg.onload = () => {
  addCraterToDisplacement(earth.material.displacementMap, craterImg, 30, 120, 20);
  addCraterToDisplacement(earth.material.displacementMap, craterImg, -10, 45, 15);
};







<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MapTiler 卫星地图示例（0GCZRo8V9UPQFhWV1vt6）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    body, html { margin:0; padding:0; height:100%; }
    #map { width:100%; height:100%; }
  </style>
</head>
<body>
  <div id="map"></div>
  <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
  <script>
    const MAPTILER_KEY = '0GCZRo8V9UPQFhWV1vt6'; // 在这里填入你免费注册的 MapTiler Key

    const map = new maplibregl.Map({
      container: 'map',
      style: `https://api.maptiler.com/maps/satellite/style.json?key=${MAPTILER_KEY}`,
      center: [116.391,39.907], // 北京中心
      zoom: 15 // 街道/建筑级别
    });

    // 添加缩放控件
    map.addControl(new maplibregl.NavigationControl());
    // 可选：添加全屏控件
    map.addControl(new maplibregl.FullscreenControl());
  </script>
</body>
</html>


map.setMaxBounds([[-179.999, -85], [179.999, 85]]);


